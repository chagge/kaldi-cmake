###############################################################
# Common project initializations made here. 
# Do not edit this file unless you are sure what you are doing.
###############################################################

# Установим тип сборки по умолчанию
if (NOT DEFINED CMAKE_BUILD_TYPE)
	set(CMAKE_BUILD_TYPE Release)
endif()

# Default CMAKE_<CONFIG>_POSTFIX
set(CMAKE_DEBUG_POSTFIX "D")
set(CMAKE_MINSIZEREL_POSTFIX "S")
set(CMAKE_RELWITHDEBINFO_POSTFIX "RD")

# Сохраним путь до SOURCE и BINARY директорий корневого проекта
if (NOT DEFINED ROOT_PROJECT_SOURCE_DIR)
	set(ROOT_PROJECT_SOURCE_DIR ${PROJECT_SOURCE_DIR})
endif()
if (NOT DEFINED ROOT_PROJECT_BINARY_DIR)
	set(ROOT_PROJECT_BINARY_DIR ${PROJECT_BINARY_DIR})
endif()

message ( "-- CMAKE_SYSTEM_NAME: ${CMAKE_SYSTEM_NAME}" )

# Platform specific definitions
if (${CMAKE_SYSTEM_NAME} MATCHES "Linux")
	set(LINUX 1)
	message (STATUS "Operating system is: Linux")
endif()

if (${CMAKE_SYSTEM_NAME} MATCHES "Windows")
	set(WINDOWS 1)
	message (STATUS "Operating system is: Windows")
	add_definitions(-DWIN32)
endif()

if (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
    set(DARWIN 1)
    # Note: UNIX=1 already defined on Mac OS X
    message (STATUS "Operating system is: Mac OS X (Darwin)")
endif()

# Load options lists
#if (WINDOWS)
#	include (CMakeOptionsWindows.cmake)
#elseif(LINUX)
#    include (CMakeOptionsLinux.cmake)
#elseif(DARWIN)
#    include (CMakeOptionsDarwin.cmake)
#endif()

# Check if we have all needed version enviroment variables set, 
# otherwise fall back to the default version of 1.0.0.0
if (DEFINED ENV{MAJOR} AND DEFINED ENV{MINOR} AND DEFINED ENV{BUILD} AND DEFINED ENV{REVISION})
	set(${PROJECT_NAME}_VERSION_MAJOR $ENV{MAJOR})
	set(${PROJECT_NAME}_VERSION_MINOR $ENV{MINOR})
	set(${PROJECT_NAME}_VERSION_BUILD $ENV{BUILD})
	set(${PROJECT_NAME}_VERSION_REVISION $ENV{REVISION})

else()
	set(${PROJECT_NAME}_VERSION_MAJOR 1)
	set(${PROJECT_NAME}_VERSION_MINOR 0)
	set(${PROJECT_NAME}_VERSION_BUILD 0)
	set(${PROJECT_NAME}_VERSION_REVISION 0)
endif()
set(${PROJECT_NAME}_VERSION "${${PROJECT_NAME}_VERSION_MAJOR}.${${PROJECT_NAME}_VERSION_MINOR}.${${PROJECT_NAME}_VERSION_BUILD}")
set(${PROJECT_NAME}_VERSION_FULL "${${PROJECT_NAME}_VERSION_MAJOR}.${${PROJECT_NAME}_VERSION_MINOR}.${${PROJECT_NAME}_VERSION_BUILD}.${${PROJECT_NAME}_VERSION_REVISION}")


# Set path to local CMake modules
set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${PROJECT_SOURCE_DIR}/cmake)

# include modules
include (MemcheckTest)

# architecture
if (NOT DEFINED PROCESSOR_BITS)
    if (CMAKE_SIZEOF_VOID_P MATCHES "4")
        set(PROCESSOR_BITS 32)
    elseif (CMAKE_SIZEOF_VOID_P MATCHES "8")
        set(PROCESSOR_BITS 64)
    endif()
endif()

message ("-- CMAKE_GENERATOR: ${CMAKE_GENERATOR}" )
# Define ARCHITECTURE, TOOLSET and PLATFORM varibales
if (CMAKE_GENERATOR STREQUAL "Visual Studio 10")
	set (ARCHITECTURE "win32")
	set (TOOLSET "vs2010")
	set (PROCESSOR_BITS 32)
elseif (CMAKE_GENERATOR STREQUAL "Visual Studio 10 Win64")
	set (ARCHITECTURE "win64")
	set (TOOLSET "vs2010")
	set (PROCESSOR_BITS 64)
elseif (CMAKE_GENERATOR STREQUAL "Visual Studio 8 2005")
	set (ARCHITECTURE "win32")
	set (TOOLSET "vs2005")
	set (PROCESSOR_BITS 32)
elseif (CMAKE_GENERATOR STREQUAL "Visual Studio 8 2005 Win64")
	set (ARCHITECTURE "win64")
	set (TOOLSET "vs2005")
	set (PROCESSOR_BITS 64)
elseif(CMAKE_GENERATOR STREQUAL "NMake Makefiles")
	if (CMAKE_SIZEOF_VOID_P MATCHES "8")
		set (ARCHITECTURE "win64")
		set (PROCESSOR_BITS 64)
	else()
		set (ARCHITECTURE "win32")
		set (PROCESSOR_BITS 32)
	endif()
	
	set (TOOLSET "vs2010")
elseif (CMAKE_GENERATOR STREQUAL "Visual Studio 11 Win64")
	set (ARCHITECTURE "win64")
	set (TOOLSET "vs2012")
	set (PROCESSOR_BITS 64)
	# Хак: по дефолту максимальное количество параметров у шаблона не может превышать 10
	add_definitions(-D_VARIADIC_MAX=10)
elseif (CMAKE_GENERATOR STREQUAL "Visual Studio 11")
	set (ARCHITECTURE "win32")
	set (TOOLSET "vs2012")
	set (PROCESSOR_BITS 32)
	# Хак: по дефолту максимальное количество параметров у шаблона не может превышать 10
	add_definitions(-D_VARIADIC_MAX=10)
endif()

#add_definitions(-DPROCESSOR_BITS=${PROCESSOR_BITS})
message (STATUS "Compiling for ${PROCESSOR_BITS}-bit system")

if (LINUX)
	if (EXISTS /etc/issue)
		file (READ /etc/issue ISSUE_FILE)
		string (REGEX MATCH ".*Ubuntu.*"  IS_UBUNTU ${ISSUE_FILE})
		string (LENGTH "${IS_UBUNTU}" IS_UBUNTU)
		if (IS_UBUNTU)
			set (UBUNTU 1)
			message (STATUS "  Distribution Ubuntu")
		endif()
		string (REGEX MATCH ".*CentOS.*"  IS_CENTOS ${ISSUE_FILE})
		if (IS_CENTOS)
			string (REGEX MATCH ".*6\\..*"  IS_CENTOS6 ${ISSUE_FILE})
			if(IS_CENTOS6)
				set (CENTOS6 1)
				message (STATUS "  Distribution CentOS6")
			else()
				set (CENTOS 1)
				message (STATUS "  Distribution CentOS")
			endif()
		endif()
		string (REGEX MATCH ".*Arch Linux.*"  IS_ARCHLINUX ${ISSUE_FILE})
		if (IS_ARCHLINUX)
			set (ARCHLINUX 1)
			message (STATUS "  Distribution Arch Linux")
		endif()
	else()
		message (STATUS "  Can't determine distribution name")
	endif()
endif()

if (LINUX)
	set (ARCHITECTURE linux${PROCESSOR_BITS})
	if (UBUNTU)
		set (TOOLSET ubuntu)
	elseif (CENTOS6)
		set (TOOLSET centos6)
	elseif (CENTOS)
		set (TOOLSET centos)
	elseif (ARCHLINUX)
		set (TOOLSET archlinux)
	endif()
	if (PROCESSOR_BITS STREQUAL "32")
	    set_property(GLOBAL PROPERTY FIND_LIBRARY_USE_LIB64_PATHS OFF)
	endif()
endif()

if(DARWIN)
    set (ARCHITECTURE darwin${PROCESSOR_BITS})
    set (TOOLSET "macosx")
endif()

set (PLATFORM ${ARCHITECTURE}-${TOOLSET})
message(STATUS "Platform is: ${PLATFORM}")

# If STC_LIBRARY_BUILD_TYPE is not defined, set it to SHARED
set(STC_LIBRARY_BUILD_TYPE SHARED)

# Default link and include paths
include_directories("include")
link_directories(${PROJECT_BINARY_DIR})

# Default compiler flags

if (MSVC)
    add_definitions(-DNOMINMAX) # to force Visual Studio to not define min, max macros
	set (CMAKE_CXX_FLAGS "/EHa /wd4099 /D_CRT_SECURE_NO_WARNINGS")
else()
#    set (CMAKE_CXX_FLAGS "-Wall --visibility=hidden -finput-charset=CP1251 -fexec-charset=CP1251 -pthread")
    set (CMAKE_CXX_FLAGS "-Wall -finput-charset=CP1251 -fexec-charset=CP1251 -pthread -fPIC")
#    if (PROCESSOR_BITS STREQUAL "64") 
#	    set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC")
#	endif()
endif()

# Default RPATH
set(CMAKE_SKIP_BUILD_RPATH FALSE)
set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
if (PROCESSOR_BITS STREQUAL "64") 
    set(CMAKE_INSTALL_RPATH "\\$ORIGIN:\\$ORIGIN/../lib:\\$ORIGIN/../lib64")
else()
    set(CMAKE_INSTALL_RPATH "\\$ORIGIN:\\$ORIGIN/../lib:\\$ORIGIN/../lib32")
endif()
set(CMAKE_INSTALL_RPATH_USE_LINK_PATH FALSE)

# If we have a debug build then add D suffix to it, i.e. CommonD.dll / libCommonD.so
if (CMAKE_BUILD_TYPE STREQUAL "Debug")
	set (DEBUG_SUFFIX "D")
	set (DEBUG_SUFFIX_LC "d")
endif()

# ENABLE_TESTING
set (ENABLE_TESTING $ENV{ENABLE_TESTING})

# Path to the directory containing unit tests
set (PROJECT_TEST_DIR "${PROJECT_SOURCE_DIR}/test")

# Enable test coverage
if (CODE_COVERAGE_ENABLED AND (CMAKE_COMPILER_IS_GNUCXX OR CMAKE_COMPILER_IS_GNUCC))
	set (CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} "-fprofile-arcs -ftest-coverage")
endif()


# Load source file lists
include (CMakeHeaderFileList.cmake)
include (CMakeSourceFileList.cmake)


###############################################
########### Macros and Functions ##############
###############################################

# ------------------------------------------------------------------------------------
# Externals macro
macro (add_externals EXTERNALS_NAME)
	message(STATUS "Adding ${EXTERNALS_NAME} externals")
    # сохраним имя платформы во временную переменную
	set(_PLATFORM ${PLATFORM})
    # Проверим, существует ли в externals сборка нужного нам модуля под нашу платформу
    if(EXISTS ${ARGN})
        # Да, он существует в указанной директории. Сохраним путь до него в переменную EXTERNALS_DIR
	    set (EXTERNALS_DIR ${ARGN})
    elseif(EXISTS ${PROJECT_SOURCE_DIR}/externals/${EXTERNALS_NAME}/${_PLATFORM})
        # Да, он существует в дир. проекта. Сохраним путь до него в переменную EXTERNALS_DIR
	    set (EXTERNALS_DIR ${PROJECT_SOURCE_DIR}/externals/${EXTERNALS_NAME}/${_PLATFORM})
	else()
        # Нет, его нет. Устанавливаем платформу по умолчанию (CentOS)
	    message(STATUS "  Falling back to CentOS externals")
	    set (_PLATFORM "linux${PROCESSOR_BITS}-centos")
	    set (EXTERNALS_DIR ${PROJECT_SOURCE_DIR}/externals/${EXTERNALS_NAME}/${_PLATFORM})
	endif()
	
	message(STATUS "  ${EXTERNALS_NAME} found at:  ${EXTERNALS_DIR}")
	
    # Сохраним имена поддиректорий в свои переменные
	set(${EXTERNALS_NAME}_INCLUDE_DIR "${EXTERNALS_DIR}/include")
	set(${EXTERNALS_NAME}_LIBRARY_DIR "${EXTERNALS_DIR}/lib")
	set(${EXTERNALS_NAME}_BINARY_DIR "${EXTERNALS_DIR}/bin")

    # Подключим include и lib директории к текущему проекту
	include_directories(${${EXTERNALS_NAME}_INCLUDE_DIR})
	link_directories(${${EXTERNALS_NAME}_LIBRARY_DIR})
	if (NOT WINDOWS)
	    link_directories(${${EXTERNALS_NAME}_LIBRARY_DIR}/${CMAKE_BUILD_TYPE})
	endif()
	
    # Теперь скопируем dll в текущую директорию сборки для того,
    # чтобы при запуске приложения (например теста) он находил нужные dll.
	if (WINDOWS)
        # Составляем список всех dll
		file (GLOB ${EXTERNALS_NAME}_DLL_FILES ${EXTERNALS_DIR}/bin/*.dll)
		file (GLOB ${EXTERNALS_NAME}_DLL_FILES_DEBUG ${EXTERNALS_DIR}/bin/Debug/*.dll)
		file (GLOB ${EXTERNALS_NAME}_DLL_FILES_RELEASE ${EXTERNALS_DIR}/bin/Release/*.dll)
        # Скопируем их
		file (COPY ${${EXTERNALS_NAME}_DLL_FILES_DEBUG} DESTINATION ${ROOT_PROJECT_BINARY_DIR}/Debug)
		file (COPY ${${EXTERNALS_NAME}_DLL_FILES_RELEASE} DESTINATION ${ROOT_PROJECT_BINARY_DIR}/Release)
		file (COPY ${${EXTERNALS_NAME}_DLL_FILES} DESTINATION ${ROOT_PROJECT_BINARY_DIR}/Debug)
		file (COPY ${${EXTERNALS_NAME}_DLL_FILES} DESTINATION ${ROOT_PROJECT_BINARY_DIR}/Release)
    elseif (DARWIN)
		file (GLOB ${EXTERNALS_NAME}_DLL_FILES ${EXTERNALS_DIR}/lib/lib*.dylib)
		file (COPY ${${EXTERNALS_NAME}_DLL_FILES} DESTINATION ${ROOT_PROJECT_BINARY_DIR})
	elseif (UNIX)
        # То же самое под Unix
		file (GLOB ${EXTERNALS_NAME}_DLL_FILES ${EXTERNALS_DIR}/lib/lib*.so*)
		file (COPY ${${EXTERNALS_NAME}_DLL_FILES} DESTINATION ${ROOT_PROJECT_BINARY_DIR})
	endif()
	message(STATUS "  ${EXTERNALS_NAME} dynamic libs: ${${EXTERNALS_NAME}_DLL_FILES}")
    # Добавим список dll для данного external'а в список всех dll
	set (EXTERNALS_DLL_FILES_ALL ${EXTERNALS_BINARY_FILES_ALL} ${${EXTERNALS_NAME}_DLL_FILES})
endmacro()
# ------------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# add_module_by_path function
function(add_module_by_path MODULE_NAME MODULE_PATH)
    if ((IS_DIRECTORY ${MODULE_PATH}/${PLATFORM}/bin) OR (IS_DIRECTORY ${MODULE_PATH}/${PLATFORM}/lib))
        # Если заданный путь - директоря установки, то подключаем ее как external
        add_externals (${MODULE_NAME} ${MODULE_PATH}/${PLATFORM})
        #include(${MODULE_PATH}/${PLATFORM}/exports.cmake)
        set (${MODULE_NAME}_FOUND "bin" PARENT_SCOPE)
    elseif(EXISTS ${MODULE_PATH}/CMakeLists.txt)
        # Если заданный путь - директоря с исходниками, то подключаем ее через add_subdirectory
        add_subdirectory(${MODULE_PATH} ${MODULE_NAME}.dir)
        include_directories(${MODULE_PATH}/include)
        set (${MODULE_NAME}_FOUND "src" PARENT_SCOPE)
    else()
        message(STATUS "Specified path doesn't contain any module (MODULE_PATH: ${MODULE_PATH})")
    endif()
endfunction()
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# add_module_by_full_path function
function(add_module_by_full_path MODULE_NAME MODULE_PATH)
    if ((IS_DIRECTORY ${MODULE_PATH}/bin) OR (IS_DIRECTORY ${MODULE_PATH}/lib))
        # Если заданный путь - директоря установки, то подключаем ее как external
        add_externals (${MODULE_NAME} ${MODULE_PATH})
        #include(${MODULE_PATH}/exports.cmake)
        set (${MODULE_NAME}_FOUND "bin" PARENT_SCOPE)
    elseif(EXISTS ${MODULE_PATH}/CMakeLists.txt)
        # Если заданный путь - директоря с исходниками, то подключаем ее через add_subdirectory
        add_subdirectory(${MODULE_PATH} ${MODULE_NAME}.dir)
        include_directories(${MODULE_PATH}/include)
        set (${MODULE_NAME}_FOUND "src" PARENT_SCOPE)
    else()
        message(STATUS "Specified path doesn't contain any module (MODULE_PATH: ${MODULE_PATH})")
    endif()
endfunction()
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# add_module function
function (add_module MODULE_NAME)
    message(STATUS "Try to add module ${MODULE_NAME}")
    string(TOUPPER ${MODULE_NAME} MODULE_NAME_UPPER)
    
    message(STATUS "  Probing ARGN = \"${ARGN}\"")
    if (EXISTS ${ARGN})
        message(STATUS "------------------------------------------")
        add_module_by_path(${MODULE_NAME} ${ARGN})
        message(STATUS "------------------------------------------")
        message(STATUS "  ${MODULE_NAME}_FOUND: ${${MODULE_NAME}_FOUND}")
        if (DEFINED ${MODULE_NAME}_FOUND)
            return()
        endif()
    endif()
    
    message(STATUS "  Probing ${MODULE_NAME_UPPER}_MODULE_PATH = \"${${MODULE_NAME_UPPER}_MODULE_PATH}\"")
    if (EXISTS ${${MODULE_NAME_UPPER}_MODULE_PATH})
        message(STATUS "------------------------------------------")
        add_module_by_path(${MODULE_NAME} ${${MODULE_NAME_UPPER}_MODULE_PATH})
        message(STATUS "------------------------------------------")
        message(STATUS "  ${MODULE_NAME}_FOUND: ${${MODULE_NAME}_FOUND}")
        if (DEFINED ${MODULE_NAME}_FOUND)
            return()
        endif()
    endif()
    
    message(STATUS "  Probing ENV{${MODULE_NAME_UPPER}_MODULE_PATH} = \"$ENV{${MODULE_NAME_UPPER}_MODULE_PATH}\"")
    if(EXISTS $ENV{${MODULE_NAME_UPPER}_MODULE_PATH})
        message(STATUS "------------------------------------------")
        add_module_by_path(${MODULE_NAME} $ENV{${MODULE_NAME_UPPER}_MODULE_PATH})
        message(STATUS "------------------------------------------")
        message(STATUS "  ${MODULE_NAME}_FOUND: ${${MODULE_NAME}_FOUND}")
        if (DEFINED ${MODULE_NAME}_FOUND)
            return()
        endif()
    endif()
    
    message(STATUS "  Probing externals/${MODULE_NAME}/${PLATFORM}")
    if(EXISTS ${PROJECT_SOURCE_DIR}/externals/${MODULE_NAME}/${PLATFORM})
        message(STATUS "------------------------------------------")
        add_module_by_full_path(${MODULE_NAME} ${PROJECT_SOURCE_DIR}/externals/${MODULE_NAME}/${PLATFORM})
        message(STATUS "------------------------------------------")
        message(STATUS "  ${MODULE_NAME}_FOUND: ${${MODULE_NAME}_FOUND}")
        if (DEFINED ${MODULE_NAME}_FOUND)
            return()
        endif()
    endif()
    
#    file(GLOB ExtAvailForCurrentArch ${PROJECT_SOURCE_DIR}/externals/${MODULE_NAME}/${ARCHITECTURE}*)
#    foreach(MODULE_PATH ${ExtAvailForCurrentArch})
#        message(STATUS "  Probing ${MODULE_PATH}")
#        if(EXISTS ${MODULE_PATH})
#            message(STATUS "------------------------------------------")
#            add_module_by_full_path(${MODULE_NAME} ${MODULE_PATH})
#            message(STATUS "------------------------------------------")
#            message(STATUS "  ${MODULE_NAME}_FOUND: ${${MODULE_NAME}_FOUND}")
#            if (DEFINED ${MODULE_NAME}_FOUND)
#                return()
#            endif()
#        endif()
#    endforeach()

    message(FATAL_ERROR "Unable to find module ${MODULE_NAME}")

endfunction()
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
# install externals macro
macro (install_externals EXTERNALS_NAME)
	if (WINDOWS)
		install(FILES ${${EXTERNALS_NAME}_DLL_FILES}
				DESTINATION ${PLATFORM}/bin)
	elseif (UNIX)
		install(FILES ${${EXTERNALS_NAME}_DLL_FILES}
				DESTINATION ${PLATFORM}/lib)
	endif()
endmacro()
# ------------------------------------------------------------------------------------


# ------------------------------------------------------------------------------------
# add_target_compile_definitions macro
function(add_target_compile_definitions TARGET DEFINITIONS)
    get_target_property(COMPILE_DEFINITIONS ${TARGET} COMPILE_DEFINITIONS)
    if (COMPILE_DEFINITIONS MATCHES COMPILE_DEFINITIONS-NOTFOUND)
        set_target_properties(
            ${TARGET}
        PROPERTIES
            COMPILE_DEFINITIONS "${DEFINITIONS}"
        )
    else()
        set_target_properties(
            ${TARGET}
        PROPERTIES
            COMPILE_DEFINITIONS "${COMPILE_DEFINITIONS};${DEFINITIONS}"
        )
    endif()
endfunction()
# ------------------------------------------------------------------------------------


# ------------------------------------------------------------------------------------
# set_default_library_target_properties function
function (set_default_library_target_properties TARGET_NAME)

    # Установим имя выходного файла и его версию
    set_target_properties(
    	${TARGET_NAME} 
    PROPERTIES
    	VERSION "${${PROJECT_NAME}_VERSION_FULL}"		# Set version for the library. On unix it will be something like libCommon.so.1.2.3.123
    	SOVERSION "${${PROJECT_NAME}_VERSION}"			# Create a symlink to libCommon.so.1.2.3.123 named libCommon.so.1.2.3
    )
    
    # Установим флаги сборки 32/64 битной архитектуры под Unix
    # Под Windows это определяется через соответствующий генератор
    if (UNIX)
        set_target_properties(
        	${TARGET_NAME} 
        PROPERTIES
            COMPILE_FLAGS "-m${PROCESSOR_BITS}"
            LINK_FLAGS "-m${PROCESSOR_BITS}"
        )
    endif()
    
    # Установим макросы экспорта символов
    string(TOUPPER ${TARGET_NAME} TARGET_NAME_UPPER)
    get_target_property(TARGET_TYPE ${TARGET_NAME} TYPE)
    if (${TARGET_TYPE} MATCHES STATIC_LIBRARY) # Если статическая то SYMBOL_STATIC
        add_target_compile_definitions(${TARGET_NAME} ${TARGET_NAME_UPPER}_API=SYMBOL_STATIC)
    elseif(${TARGET_TYPE} MATCHES SHARED_LIBRARY) # Если динамическая то SYMBOL_EXPORT
        add_target_compile_definitions(${TARGET_NAME} ${TARGET_NAME_UPPER}_API=SYMBOL_EXPORT)
    else()
        message(FATAL_ERROR "Specified target is not a library")
    endif()

	# Установим директорию куда складывать результат - ROOT_PROJECT_BINARY_DIR
    set_target_properties(
    	${TARGET_NAME} 
    PROPERTIES
		LIBRARY_OUTPUT_DIRECTORY ${ROOT_PROJECT_BINARY_DIR}
		ARCHIVE_OUTPUT_DIRECTORY ${ROOT_PROJECT_BINARY_DIR}
		RUNTIME_OUTPUT_DIRECTORY ${ROOT_PROJECT_BINARY_DIR}
	)
    
endfunction()
# ------------------------------------------------------------------------------------


# ------------------------------------------------------------------------------------
# set_default_executable_target_properties
function (set_default_executable_target_properties TARGET_NAME)
    # Установим флаги сборки 32/64 битной архитектуры под Unix
    # Под Windows это определяется через соответствующий генератор
    if (UNIX)
        set_target_properties(
        	${TARGET_NAME} 
        PROPERTIES
            COMPILE_FLAGS "-m${PROCESSOR_BITS}"
            LINK_FLAGS "-m${PROCESSOR_BITS}"
        )
    endif()

	# Установим директорию куда складывать результат - ROOT_PROJECT_BINARY_DIR
    set_target_properties(
    	${TARGET_NAME} 
    PROPERTIES
		LIBRARY_OUTPUT_DIRECTORY ${ROOT_PROJECT_BINARY_DIR}
		ARCHIVE_OUTPUT_DIRECTORY ${ROOT_PROJECT_BINARY_DIR}
		RUNTIME_OUTPUT_DIRECTORY ${ROOT_PROJECT_BINARY_DIR}
	)
endfunction()
# ------------------------------------------------------------------------------------


# ------------------------------------------------------------------------------------
# import_shared_library
# Импорт релизной или отладочной динамической библиотеки в зависимости от типа конфигурации
function(import_shared_library TARGET LIB_NAME)
    target_link_libraries(${TARGET} debug ${LIB_NAME}${CMAKE_DEBUG_POSTFIX} optimized ${LIB_NAME})
    string(TOUPPER ${LIB_NAME} LIB_NAME_UPPER)
    add_target_compile_definitions(${TARGET} ${LIB_NAME_UPPER}_API=SYMBOL_IMPORT)
    if (TARGET ${LIB_NAME})
        add_dependencies(${TARGET} ${LIB_NAME})
    endif()
endfunction()

# Импорт релизной динамической библиотеки в не зависимости от типа конфигурации
function(import_optimized_shared_library TARGET LIB_NAME)
    target_link_libraries(${TARGET} ${LIB_NAME})
    string(TOUPPER ${LIB_NAME} LIB_NAME_UPPER)
    add_target_compile_definitions(${TARGET} ${LIB_NAME_UPPER}_API=SYMBOL_IMPORT)
    if (TARGET ${LIB_NAME})
        add_dependencies(${TARGET} ${LIB_NAME})
    endif()
endfunction()
# ------------------------------------------------------------------------------------


# ------------------------------------------------------------------------------------
# import_static_library
# Импорт релизной или отладочной статической библиотеки в зависимости от типа конфигурации
function(import_static_library TARGET LIB_NAME)
    target_link_libraries(${TARGET} debug ${LIB_NAME}${CMAKE_DEBUG_POSTFIX} optimized ${LIB_NAME})
    string(TOUPPER ${LIB_NAME} LIB_NAME_UPPER)
    add_target_compile_definitions(${TARGET} ${LIB_NAME_UPPER}_API=)
    if (TARGET ${LIB_NAME})
        add_dependencies(${TARGET} ${LIB_NAME})
    endif()
endfunction()

# Импорт релизной статической библиотеки в не зависимости от типа конфигурации
function(import_optimized_static_library TARGET LIB_NAME)
    target_link_libraries(${TARGET} ${LIB_NAME})
    string(TOUPPER ${LIB_NAME} LIB_NAME_UPPER)
    add_target_compile_definitions(${TARGET} ${LIB_NAME_UPPER}_API=)
    if (TARGET ${LIB_NAME})
        add_dependencies(${TARGET} ${LIB_NAME})
    endif()
endfunction()
# ------------------------------------------------------------------------------------

function(configure_rc_file _NAME _ORIGINAL_FILENAME _FILE_DESCRIPTION)
    if (WINDOWS)
        set(VERSION_RC_FILE ${_NAME}.rc PARENT_SCOPE)
        set(RC_MAJOR ${${PROJECT_NAME}_VERSION_MAJOR})
        set(RC_MINOR ${${PROJECT_NAME}_VERSION_MINOR})
        set(RC_BUILD ${${PROJECT_NAME}_VERSION_BUILD})
        set(RC_REVISION ${${PROJECT_NAME}_VERSION_REVISION})
        set(RC_COMPANY_NAME "Speech Technology Center")
        set(RC_FILE_DESCRIPTION ${_FILE_DESCRIPTION})
        set(RC_INTERNAL_NAME ${_NAME})
        set(RC_COPYRIGHT "Copyright (C) 2011")
        set(RC_ORIGINAL_FILENAME ${_ORIGINAL_FILENAME})
        set(RC_PRODUCT_NAME ${_NAME})
        configure_file(${PROJECT_SOURCE_DIR}/cmake/Version.rc.in ${PROJECT_BINARY_DIR}/${_NAME}.rc)
    endif()
endfunction()


